[[PageOutline]]
= HTML5 Client Technical Details =
Noteworthy technical !SpiderOak HTML5 client project technical details. See
[[HTML5ClientProject]] for project status, etc.

== Architectural Elements ==

=== `ContentNode` Data Model ===
The `ContentNode` object hierarchy provides a data model around which
obtaining, assimilating, and presenting the !SpiderOak-managed user content
data is organized - storage devices versus share rooms, and their contained
folders and file "nodes".

* `ContentNode` - Basis
  * `RootContentNode` - A consolidated container of storage and share roots
  * `FolderContentNode` - General behaviors used by storage and share folders
  * `FileContentNode` - General behaviors used by storage and share files
  * `StorageNode` - Backups content
    * `RootStorageNode`
    * `DeviceStorageNode`
    * `DirectoryStorageNode`
    * `FileStorageNode`
  * `ShareNode` - Share Rooms and their contents
    * `OriginalRootShareNode` - The list of share rooms published by the account
    * `PublicRootShareNode` - Any share rooms visited
    * `RoomShareNode` - a public or original share room
    * `DirectoryShareNode`
    * `FileShareNode`

=== Content Addressing ===

Content model elements are address by the URLs of their JSON content items:

* as the '#' fragment identifiers of the app's URL, for jQuery Mobile
  changePage navigation, and
* as the key for retrieval (and allocation) within the app's internal node
  database, mediated by the spideroak.content_node_manager object.

The app adds a few encompassing objects: "root nodes". They contain and
organize the actual content hierarchies.  The root nodes have URL
addresses, more or less situated at the top of their respective content
hierarchies.

* The actual content items are indexed in the content_node_manager by their
  JSON access URLs, and addressed in app URLs as the fragment identifiers.
* The `RootStorageNode` contains the backup storage items, with a URL
  consisting of the storage server host (which can vary) and a trimmed,
  b32 encoding of the account name.  Access to the contained items depends
  on login, at which point the storage host server is determined.
* The list of account-originated share rooms is collected
  within the `OriginalRootShareNode`. It has a special JSON address on the
  server within each account's storage root.  The original share rooms are
  situated with all the public share rooms, in...
* The `PublicRootShareNode` has a URL that is the common stem of all visited
  !SpiderOak share rooms.
* A encompassing root node, the `ComboRootContentNode`, contains all the
  other roots, and presents their contents in a consolidated view.  The app
  uses an arbitrary, internal address for it, sufficiently URL-like to be
  recognized as such by the jQm URL traversal machinery in changePage().

The spideroak.content_node_manager is the broker by which everything
obtains nodes, given their URL handles. It also is how nodes are nodes are
allocated, when first encountered, and so requires identification of the
parent node in any situations that might be first encounters (or first
encounters after a logout).

=== Organization of Content Traversal ===

There are a few kinds of structural connections by which users navigate the
content hierarchies.

* Navigation into contained items: Downwards navigation is by clicking on
  the items presented as the contents of some kind of folder, including
  share room and storage devices, their contained folders, and the various
  root containers.

* The items have URLs consisting of the application's address followed by
  a fragment identifier consisting of the content's address.  The app's
  [#DynamicPageTraversal dynamic page traversal machinery] (below)
  retrieves the JSON data for content nodes and populates and presents an
  application node for it.

* Besides content items and the special provisions listed below, fragment
  addresses are simple locations of jQuery mobile page divs
  ([data-role="page"]), conveyed to the regular jQm pageChange if none of
  the specific conditions obtain.

* Some of the encompassing root nodes, like the `RootContentNode` and
  `PublicRootShareNode`, use static DOM templates, with corresponding
  static document addresses.  Intra-document (fragment) links to those
  static template addresses are mapped to the addresses of corresponding
  root content nodes using a `handle_content_visit()` helper,
  `internalize_url()`.

* The special consolidated root node, `RootContentNode`, arranges to
  present the contents of the respective actual content roots, the
  `RootStorageNode`, `OriginalRootShareNode`, and `PublicRootShareNode`.
  Thus the `RootContentNode` effectively shares downward-navigation
  containment of the actual content roots.

* Some addresses are of application-managed, non-content-specific
  facilities, like 'logout'.  These are listed in the `document_addrs`
  object, which is used by `handle_content_visit()` to dispatch the
  listed functions.

* Navigation from more contained nodes to less contained ones depends on
  registration of the parent node URLs in the offspring when the offspring
  nodes are allocated.

  The respective actual content root's items are produced so that the
  consolidated root is registered as their parent.  Thus, outward
  navigation from the top level content items (storage devices and share
  rooms) goes to the `RootContentNode` consolidated root, rather than the
  actual content roots.

In this way, the content-specific root nodes are skipped in normal
navigation.  This frees them for use providing management activities for
their respective collections:

* `RootStorageNode`: (eventually) adjusting backup coverage
* `OriginalRootShareNode`: (eventually) managing the share rooms published
  by the account
* `PublicRootShareNode`: adding to and omitting from the collection of
  share rooms being visited.

=== Application !Entry/Init Overview ===
* $(document).ready() function calls spideroak.init()
* spideroak.init():
  * establishes the traversal handler
  * initializes some application state
  * prepares the login form submit callback and visibility controls
  * arranges the combo-root gradual fade-in
  * fetches persistent settings
  * does a traversal to the combo root `RootContentNode`.
* the `RootContentNode.visit()` and other content node `.visit()` methods
  are described [#DyanamicPageTraversal next].

=== Dynamic Page Traversal ===
Most content nodes ([#ContentNodeDataModel in the data model, above]) are
presented as jQuery Mobile "pages" - `<div data-role="page>`. They are
generated dynamically from cloned copies of static template DOM nodes,
found in `SpiderOak.html`, upon in-app traversal of content URLs (see
[#ContentAddressing Content Addressing], above).
* The spideroak object's `handle_content_visit()` method is assigned to
  handle the jQuery Mobile `pagebeforechange` event, which tracks changes
  to the browser's `location.hash` setting.

  Our handle_content_visit() routine discontinues default jQm traversal
  machinery only for handling of string addresses.  That way, we can (and
  do) use the standard jQm traversal facilities for the jQm objects that
  our machinery fabricates, by passing them to $.mobile.changePage() as
  jQm objects.
* A few different classes of addresses are used in the application, as
  described in the [#OrganizationofContentTraversal Content Traversal]
  section, above.
* For navigation URLs that go to application content, including the user's
  !SpiderOak-managed content, we:
  * Fetch a suitable `ContentNode`-based object for the node using
  * `spideroak.content_node_manager.get()`, which returns an already
    existing node, if any, or else allocates a new one with suitable
    initial settings.
  * The obtained `ContentNode` object uses its `.visit()` method to
    handle the visit - fabricating a (jQm <div data-role="page"/>) page
    object and using the traversal machinery to visit it.
* In most cases, `ContentNode.visit()`:
  * Fetches the node contents from the server if necessary (''intially,
    always necessary'')
  * Gets a jQuery object for the node's data-role="page", cloning the
    !SpiderOak.html id="content-page-template" &lt;div&gt; if it hasn't
    already gotten a copy this way, and adjusting the basic structure.
  * Fills in the page header and footer according to the node's navigation
    context.  Different types of nodes have different actions and relative
    ascending navigation routes associated with them.
  * Populates the page listview with entries for the node's contents, or
    special activities associated with the node.

* The `RootContentNode`'s `.visit()` method is different.  It dispatches a
  visit to the `PublicRootShareNode`, `RootStorageNode` and
  `OriginalRootShareNode`.  All of those visits are delegated such that:
  1. The delegated presentations do not take browser focus (using the
     'passive' mode option), leaving focus on the `RootContentNode`, and
  2. the `RootContentNode` is notified of success, along with an
     indicator of the transaction that succeeded, so it can redisplay its
     consolidated content view, as it notifications are received.
  3. The visit is contingent to receiving success status notification
     from the `RootStorageNode` visit, since both depend on successful
     authentication, while access to contents of the
     `PublicRootShareNode` does not.
     * If the `RootStorageNode` visit succeeds, the `OriginalRootShareNode`
       visit is dispatched.
     * If the `RootStorageNode` visit fails, the `RootContentNode` presents
       the login form, with the username filled in and Remember Me is
       activated, as appropriate.
See [#ContentNodenavigationmodes below] for details about the navigation
modes.

=== Content Node navigation modes ===
Special navigation behaviors are supported using query (search) parameters
on the node hash locations, translated to the node_opts parameter passed
through the `.visit()`, `.provision*()`, and `.show()`/`.layout*()` node
methods.  (Some modes can only be used via the mode_opts method parameters,
and not passed as URL query parameters.)

Currently implemented modes include:
* `passive`: when showing a node, just adjust the DOM $page, don't do
  $.mobile.changePage(). Useful for page updates in the background, or for
  the `RootContentNode` composite page, which is informed by combined subnode
  updates.
* `notify_callback`: report visit success or failure to this callback.
  The callback requires: the visit success (true or false), the
  accompanying value of `notify_token`, and on failure, the XMLHttpResponse
  (xhr) object.
* `notify_token`: object to be passed back to `notify_callback`. To be used
  by the initiator to identify the transaction and convey useful state.
* `actions_menu_fabricator`: Function to be used by item layout routine. The
  callback is given the URL of the subject item, and returns an actions menu
  to be used as the item's popup-menu
  [http://jquerymobile.com/test/docs/lists/lists-split.html split-button]
  for the item.
* `refresh`: refetch the data for the node.
* `action`: arrange for menu of actions available for this item.
  Eg, so `ContentNode.layout_item$()` can provide the proper links to elicit
  the menu, and `RoomShareNode.visit()` can present the menu and implement
  the actions.

=== Content and Operational Menus ===
Elaborate actions on content, like adding and removing share nodes, is
implemented with a combination of specific
[#ContentNodenavigationmodes content navigation modes].

* The state is conveyed in the address domain using the URL query string.

* In the procedural domain, it is conveyed using the mode_opts parameter.
  `handle_content_visit()` translates from URL to mode_opts using
  `query_params()`.

=== Storage and Share Rooms ===
Content urls are recognized by virtue of beginning with one of the
registered content roots.

The storage root is registered when the user logs in.

The client keeps track of two share rooms roots:
* the collection of share rooms that belongs to the logged-in account,
  known here as "personally owned share rooms", or "personal share rooms",
* the collection of share rooms that the client has been used to visit,
  or familiar "public share rooms".

The account login procedure includes a provision for redirecting the
storage access from the default server to secondary ones, for those
accounts that have their storage service provided by secondary servers.
This redirection step is the reason for the elaborate storage_login
function, which recurses to the indicated server when required.

== Incidental Technical Details and Hanging Issues ==
=== Special Browser Requirements ===
While developing the html5 client app I did not have the luxury of
situating the code to reside within the same domain as the storage
servers.  To get around [#HTML5ClientAppSameOriginIssues CORS restrictions]
(without JSONP, which the SpiderOak storage repo does not accept), I needed
to run my browser with drastically reduced security.  I used Chip Black's
suggestions for doing so with Google Chrome (and haven't figured
out how to do that with Firefox, even when using the Force CORS addon -
suggestions welcome).

Here are the options you need to pass to Chrome:

* `--allow-file-access-from-files --allow-http-access-from-files --disable-web-security --enable-file-cookies`

To avoid using an insecure browser as my primary browsing session, I
installed a copy of
[https://tools.google.com/dlpage/chromesxs Chrome Canary], so I can run a
separate, insecure session concurrent with my regular one.  I haven't hit
any problems specific to running Canary, but I may have been lucky in the
[https://spideroak.com/browse/share/klm/coalmine particular MacOS Canary build]
that I'm using.  If you hit odd problems trying to get Canary going, try
restarting regular Chrome with the arguments, just to establish that things
work.

For more details about CORS restrictions and the project, see
[[HTML5ClientAppSameOriginIssues]].

=== Managing the UI Theme ===
The default set of jQuery Mobile theme swatches get us near enough to
Mike's designs to be worth building on. The jQm theme roller gets us
closer, but unfortunately its' resolution is too low to avoid the need for
custom tailoring and contortions. It's necessary to know some details about
using the tool in order to continue to leverage its benefits while
preserving our custom tailoring.

==== Maintaining our theme through the theme roller ====
The most essential maintenance routine is feeding our tailored css back
into the tool in order to use its minification feature, use the tool for
the limited adjustments it can do, and eventually, use it to upgrade to
subsequent jQm versions.

To do so:
* Visit the tool at http://jquerymobile.com/themeroller/
* Open the "Import (or Upgrade)" activity
* Enter our adjusted css/themes/iphone.css in the text box and hit Import
* Make adjustments
* Use the "Download (theme zip file)" activity to get the zip file
* Put in place copies of the desired artifacts - .css, .min.css, and incidentals

==== Interspersing theme swatches on pages ====
Because button and list item styles are used across theme swatch page
elements (header, content, footer), we sometimes have to use different
swatches for different parts of the same page.

==== Generating our basic theme, in the first place ====
In case we need to re-derive our theme, it's based closely on the default
jQm theme, using the following procedure:

0. Visit http://jquerymobile.com/themeroller/
1. Use "Import or Upgrade" tab and "Import default theme"
2. Turn swatch A to stark white:
   - Copy the white patch to the header
   - Set header/footer background gradient to be #ffffff to #ffffff
   - Copy the white patch to the content body
   - Set content background gradient to be #ffffff to #ffffff
3. Download (with name "spideroak")
4. Unzip in css subdir, or elsewhere and copy out the specific artifacts.

I've added a theme swatch "f" to provide !SpiderOak orange buttons and
other elements.

At this point there are enough tweaks that you probably want to do any
theme rolling
[#Maintainingourthemethroughthethemeroller based on our existing code],
rather than starting again from scratch.

==== Special caution on reused content node pages ====
jQuery Mobile DOM "enhancements" don't just involve adding class (and
other) attributes to tags - structures are injected around things, as
well.  This means that elements location in the DOM may be different, before
and after enhancement. For example, the header button labels and icons get
enveloped in structures, so that you have to look in the new spot before
just changing the location where they were originally found.

As of 2012-05-30, `ContentNode.prototype.layout_header_fields()` shows
examples of this elaboration.

==== Consequences of typical $.ajax() requests default caching ====
Default caching of typical $.ajax() requests - including json ones - means
that normal traversal of the content hierarchy won't update after first
pass without explicitly asking for a refresh. We specifically override the
cache on explicit refreshes, but not on return by traversal to already
visited nodes. This seems like a good tradeoff, reducing server load by
requiring that the user explicitly ask for an update, but we should warn
the user about it.
