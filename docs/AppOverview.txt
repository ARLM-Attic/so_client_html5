[[PageOutline]]
= HTML5 Client Technical Details =
Noteworthy technical details of the !SpiderOak HTML5 application. See
[[HTML5ClientProject]] for project status, etc.

== Architectural Elements ==
=== Dynamic Pages ===
Storage, Share Rooms are implemented as jQuery Mobile "pages" (`<div
data-role="page>`) generated dynamically from cloned copies of static
template DOM nodes, upon in-app traversal of particular URLs.
* The spideroak object's `.handle_content_visit()` method is assigned as a
  handler to the jQuery Mobile `pagebeforechange` event, which tracks
  changes to the browser's `location.hash` setting.
* The handler discerns navigation to URLs with hash portions that are
  within the user's !SpiderOak-managed content, and:
  * Fetches a suitable `ContentNode`-based object for the node using
    `spideroak.content_node_manager.get()`, which returns an already existing
    node, if any, else manufactures a new one with suitable initial
    settings.
  * The respective `ContentNode` object uses its `.visit()` method to the
    handle the visit.
* `ContentNode.visit()`:
  * Fetches the node contents from the server if necessary (''intially,
    always necessary'')
  * Gets a jQuery object for the node's data-role="page", cloning the
    !SpiderOak.html id="storage-page-template" &lt;div&gt; and adjusts
    the basic structure, if that's not already been done.
  * Fills in the page header and footer with node's-specific navigation
    context.  The container return locations vary, and different types
    of nodes have different actions associated with them.
  * Populates the page listview with entries for the node's contents, or
    special activities associated with the node.

The storage and share room top levels, below the respective roots, have a
crucial difference. The top level storage "devices" are all part of the
single storage collection, while share rooms represent distinct
collections, which can be added and removed from the UI.  Consequently we
have to provide two modes for visiting a share room - one for managing the
collection it represents, and the other for delving into its contents.

=== `ContentNode` Prototype Hierarchy ===
The `ContentNode` object hierarchy provides for obtaining, assimilating,
and presenting the remote data describing !SpiderOak-managed user content
items - storage devices versus share rooms, and their contained folders and
file "nodes".
* `ContentNode` - Basis
  * `StorageNode` - Backups content
    * `RootStorageNode`
    * `DeviceStorageNode`
    * `DirectoryStorageNode`
    * `FileStorageNode`
  * `ShareRoomNode` - Share Rooms
    * `RootShareRoomNode`
    * `RoomShareRoomNode`
    * `DirectoryShareRoomNode`
    * `FileShareRoomNode`

(I expect to implement `DirectoryContentNode` and `FileContentNode`, to be
used by the respective storage and share room nodes.)

=== Storage and Share Rooms ===
Managed content is organized within two content roots:

- the storage root, my.storage_root_url, determined by the user's account
- the share root, which is the same across all accounts

Content urls are recognized by virtue of beginning with one of the
registered content roots. The storage root is registered when the user
logs in. The share rooms root is registered upon the registration of
any share room.

Storage access is much more complicated than share access for a couple of
reasons:

- While share room access includes something called a password, that's
  actually a part of the path to the respective share room. That is, share
  room access doesn't entail any session cookies - the "credentials" are
  encoded in the access path.

  The storage login password, on the other hand, is for authentication
  against a user account.  It entails typical web session credentials,
  conveyed by session cookies.
- The login procedure includes a provision for redirecting the storage
  attempt from the default server to secondary ones, for those accounts
  that have their storage service provided by secondary servers.  This
  redirection step is the reason for the elaborate storage_login function,
  which recurses to the indicated server when required.

== Incidental Technical Details and Hanging Issues ==
=== Special Browser Requirements ===
While developing the html5 client app I did not have the luxury of
situating the code to reside within the same domain as the storage
servers.  To get around [HTML5ClientAppSameOriginIssues CORS restrictions]
(without JSONP, which the SpiderOak storage repo does not accept), I needed
to run my browser with drastically reduced security.  I used Chip Black's
suggestions for doing so with Google Chrome (and haven't figured
out how to do that with Firefox, even when using the Force CORS addon -
suggestions welcome).

Here are the options you need to pass to Chrome:

* `--allow-file-access-from-files --allow-http-access-from-files --disable-web-security --enable-file-cookies`

To avoid using an insecure browser as my primary browsing session, I
installed a copy of
[https://tools.google.com/dlpage/chromesxs Chrome Canary], so I can run a
separate, insecure session concurrent with my regular one.  I haven't hit
any problems specific to running Canary, but I may have been lucky in the
[https://spideroak.com/browse/share/klm/coalmine particular MacOS Canary build]
that I'm using.  If you hit odd problems trying to get Canary going, try
restarting regular Chrome with the arguments, just to establish that things
work.

For more details about CORS restrictions and the project, see
[[HTML5ClientAppSameOriginIssues]].

=== Managing the UI Theme ===
The default set of jQuery Mobile theme swatches get us near enough to
Mike's designs to be worth building on. The jQm theme roller gets us
closer, but unfortunately its too low resolution to avoid some custom
tailoring and contortions to get us the rest of the way. It's necessary to
know some details about using the tool in order to continue to leverage its
benefits while preserving our custom tailoring.

==== Maintaining our theme through the theme roller ====
The most essential maintenance routine is feeding our tailored css back
into the tool in order to use its minification feature, use the tool for
the limited adjustments it can do, and eventually, use it to upgrade to
subsequent jQm versions.

To do so:
* Visit the tool at http://jquerymobile.com/themeroller/
* Open the "Import (or Upgrade)" activity
* Enter our adjusted css/themes/spideroak.css in the text box and hit Import
* Make adjustments
* Use the "Download (theme zip file)" activity to get the zip file
* Put in place copies of the desired artifacts - .css, .min.css, and incidentals

==== Interspersing theme swatches on pages ====
Because button and list item styles are used across theme swatch page
elements (header, content, footer), we sometimes have to use different
swatches for different parts of the same page.

==== Generating our basic theme, in the first place ====
In case we need to re-derive our theme, it's based closely on the default
jQm theme, using the following procedure:

0. Visit http://jquerymobile.com/themeroller/
1. Use "Import or Upgrade" tab and "Import default theme"
2. Turn swatch A to stark white:
   - Copy the white patch to the header
   - Set header/footer background gradient to be #ffffff to #ffffff
   - Copy the white patch to the content body
   - Set content background gradient to be #ffffff to #ffffff
3. Download (with name "spideroak")
4. Unzip in css subdir, or elsewhere and copy out the specific artifacts.

I've added a theme swatch "f" to provide !SpiderOak orange buttons and
other elements.

At this point there are enough tweaks that you probably want to do any
theme rolling
[#Maintainingourthemethroughthethemeroller based on our existing code],
rather than starting again from scratch.

==== Special caution on reused content node pages ====
jQuery Mobile DOM "enhancements" don't just involve adding class (and
other) attributes to tags - structures are injected around things, as
well.  This means that elements location in the DOM may be different, before
and after enhancement. For example, the header button labels and icons get
enveloped in structures, so that you have to look in the new spot before
just changing the location where they were originally found.

As of 2012-05-30, ContentNode.prototype.layout_header_fields() shows
examples of this elaboration.

==== Consequences of typical $.ajax() requests default caching ====
Default caching of typical $.ajax() requests - including json ones - means
that normal traversal of the content hierarchy won't update after first
pass without explicitly asking for a refresh. We specifically override the
cache on explicit refreshes, but not on return by traversal to already
visited nodes. This seems like a good tradeoff, reducing server load by
requiring that the user explicitly ask for an update, but we should warn
the user about it.
